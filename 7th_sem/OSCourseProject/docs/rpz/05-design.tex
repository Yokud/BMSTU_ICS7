\chapter{Конструкторский раздел}

\section{Последовательность преобразований}

На рисунках \ref{img:01_A0} и \ref{img:02_A0} представлена IDEF0 последовательность преобразований.

\includeimage
{01_A0}
{f}
{H}
{\textwidth}
{IDEF0 нулевого уровня}

\includeimage
{02_A0}
{f}
{H}
{\textwidth}
{IDEF0 первого уровня}

\section{Алгоритм перехвата функции}

На рисунке \ref{img:scheme1} представлен алгоритм перехвата функции.

\includeimage
		{scheme1}
		{f}
		{H}
		{\textwidth}
		{Алгоритм перехвата функций}
		
Далее представлено более подробное описание перехвата функций на примере функции sys\_execve.

\begin{enumerate}
	\item Пользовательский процесс выполняет SYSCALL. С помощью этой инструкции выполняется переход в режим ядра и управление передается низкоуровневому обработчику системных вызовов -- entry\_SYSCALL\_64(). Он отвечает за все системные вызовы 64-битных программ на 64-битных ядрах.
	\item Управление переходит к конкретному обработчику. Ядро передает управление высокоуровневой функции do\_syscall\_64(), написанной на С. Эта функция в свою очередь обращается к таблице обработчиков системных вызовов sys\_call\_table и вызывает оттуда конкретный обработчик по номеру системного вызова -- sys\_execve().
	\item Вызывается ftrace. В начале каждой функции ядра находится вызов функции \_\_fentry\_\_(), которая реализуется фреймворком ftrace. 
	\item ftrace вызывает разработанный коллбек. 
	\item Коллбек выполняет перехват. 
	\item ftrace восстанавливает регистры. Следуя флагу FTRACE\_SAVE\_REGS, ftrace сохраняет состояние регистров в структуре pt\_regs перед вызовом обработчиков. При завершении обработки ftrace восстанавливает регистры из этой структуры. Наш обработчик изменяет регистр \%rip -- указатель на следующую исполняемую инструкцию -- что в итоге приводит к передаче управления по новому адресу.
	\item Управление получает функция-обертка. Из-за безусловного перехода активация функции sys\_execve() прерывается. Вместо нее управление получает функция hook\_sys\_execve(). При этом все остальное состояние процессора и памяти остается без изменений, поэтому данная функция получает все аргументы оригинального обработчика и при завершении вернет управление в функцию do\_syscall\_64().
	\item Обертка вызывает оригинальную функцию. Функция hook\_sys\_execve() может проанализировать аргументы и контекст системного вызова (кто что запускает) и запретить или разрешить процессу его выполнение. В случае запрета функция просто возвращает код ошибки. Иначе же ей следует вызвать оригинальный обработчик -- sys\_execve() вызывается повторно, через указатель real\_sys\_execve, который был сохранен при настройке перехвата.
	\item Управление получает коллбек. Как и при первом вызове sys\_execve(), управление опять проходит через ftrace и передается в коллбек. 
	\item Коллбек ничего не делает. Потому что в этот раз функция sys\_execve() вызывается функцией hook\_sys\_execve(), а не ядром из do\_syscall\_64(). Поэтому коллбек не модифицирует регистры и выполнение функции sys\_execve() продолжается как обычно. 
	\item Управление возвращается обертке. 
	\item Управление возвращается ядру. Функция hook\_sys\_execve() завершается и управление переходит в do\_syscall\_64(), которая считает, что системный вызов был завершен как обычно. 
	\item Управление возвращается в пользовательский процесс. Наконец ядро выполняет инструкцию IRET (или SYSRET, но для execve() -- всегда IRET), устанавливая регистры для нового пользовательского процесса и переводя центральный процессор в режим исполнения пользовательского кода. Системный вызов (и запуск нового процесса) завершен.
\end{enumerate}

\section{Алгоритм сбора и визуализации данных}

На рисунке \ref{img:scheme2} представлен алгоритм сбора и визуализации данных о системных вызовах.

\includeimage
	{scheme2}
	{f}
	{H}
	{0.3\textwidth}
	{Алгоритм сбора и визуализации данных о системных вызовах}

\section{Структура программного обеспечения}

На рисунке \ref{img:scheme3} представлена структура программного обеспечения.

\includeimage
{scheme3}
{f}
{H}
{0.75\textwidth}
{Структура программного обеспечения}