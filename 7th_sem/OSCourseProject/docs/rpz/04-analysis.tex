\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с заданием необходимо разработать загружаемый модуля ядра для мониторинга системных вызовов sys\_clone, sys\_execve и операции с дисками bdev\_read\_page, bdev\_write\_page. На основе данных о количестве вызовов перечисленных функций составить статистику вызовов функций за определенные промежутки времени и визуализировать полученные данные.

Для решения данной задачи необходимо:

\begin{itemize}
	\item проанализировать существующие подходы для трассировки ядра и перехвата функций;
	\item изучить средства сбора статистики и визуализации;
	\item реализовать загружаемый модуль ядра.
\end{itemize}

\section{Трассировка ядра}

Под трассировкой понимается получение информации о том, что происходит внутри работающей системы. Для этого используются специальные программные инструменты, регистрирующие все события в системе.
 
Программы-трассировщики могут одновременно отслеживать события как на уровне отдельных приложений, так и на уровне операционной системы. Полученная в ходе трассировки информация может оказаться полезной для диагностики и решения многих системных проблем.

Трассировку иногда сравнивают с логгированием. Сходство между этими двумя процедурами действительно есть, но есть и различия.

Во время трассировки записывается информация о событиях, происходящих на низком уровне. Их количество исчисляется сотнями и даже тысячами. В логи же записывается информация о высокоуровневых событиях, которые случаются гораздо реже: например, вход пользователей в систему, ошибки в работе приложений, транзакции в базах данных и другие \cite{tras_sys_calls}.

Далее будут рассмотрены различные подходы к трассировке ядра и перехвату вызываемых функций.

\subsection{Linux Security API}

Linux Security API -- специальный интерфейс, созданный именно для перехвата функций. В критических местах кода ядра расположены вызовы security-функций, которые в свою очередь вызывают коллбеки, установленные security-модулем. Security-модуль может изучать контекст операции и принимать решение о ее разрешении или запрете \cite{tras_ftrace}.

Недостатками данного подхода являюся:

\begin{itemize}
	\item security-модули являются частью ядра и не могут быть загружены динамически;
	\item в системе может быть только один security-модуль (с небольшими исключениями).
\end{itemize}

Таким образом, для использования Security API необходимо использовать собственную сборку ядра Linux, в которую входит собственный security-модуль.

\subsection{Модификация таблицы системных вызовов}

В ОС Linux адреса всех обработчиков системных вызовов расположены в таблице sys\_call\_table. Подмена адреса в этой таблице приводит к смене поведения системного вызова, для которого поменяли адрес обработчика. Таким образом, сохранив адрес исходного обработчика и подставив в таблицу адрес собственного обработчика, можно перехватить любой системный вызов \cite{tras_ftrace}.

Преимуществами данного подхода являются:

\begin{itemize}
	\item контроль над любыми системными вызовами -- единственным интерфейсом к ядру у пользовательских приложений;
	\item не требуется специальная конфигурация ядра, следовательно, поддерживает максимально широкий спектр систем.
\end{itemize}

Недостатками данного подхода являются:

\begin{itemize}
	\item необходимость модифицировать таблицу системных вызовов;
	\item невозможность перехвата некоторых обработчиков. В ядрах до версии 4.16 обработка системных вызовов для архитектуры x86\_64 содержала целый ряд оптимизаций. Некоторые из них требовали того, что обработчик системного вызова являлся специальным переходником, реализованным на ассемблере. Соответственно, подобные обработчики порой сложно, а иногда и вовсе невозможно заменить на свои, написанные на языке C. Более того, в разных версиях ядра используются разные оптимизации, что так же добавляет технических сложностей.
	\item перехватываются только системные вызовы. Этот подход позволяет заменять обработчики системных вызовов, что ограничивает точки входа только ими. 
\end{itemize}

Данный подход позволяет подменить большинство обработчиков системных вызовов, что является несомненным плюсом, но также ограничивает количество функций, которые можно перехватить.

\subsection{kprobes}

kprobes -- специализированный API, в первую очередь предназначенный для отладки и трассирования ядра. Этот интерфейс позволяет устанавливать пред- и постобработчики для любой инструкции в ядре, а также обработчики на вход и возврат из функции. Обработчики получают доступ к регистрам и могут их изменять. Таким образом, можно получить как мониторинг, так и возможность влиять на дальнейший ход работы \cite{tras_ftrace}.

Преимуществами данного подхода являются:

\begin{itemize}
	\item хорошо задокументированный интерфейс, работа kprobes по возможности оптимизирована;
	\item перехват любой инструкции в ядре: это реализуются с помощью точек останова (инструкции INT3), внедряемых в исполняемый код ядра. Тем самым, можно перехватить любую функцию в ядре.
\end{itemize}

Недостатками данного подхода являются:

\begin{itemize}
	\item техническая сложность. Kprobes -- это только способ установить точку останова в любой инструкции в ядре. Для получения аргументов функции или значений локальных переменных надо знать, в каких регистрах или где в стеке они расположены, и самостоятельно их оттуда извлекать. Для блокировки вызова функции необходимо вручную модифицировать состояние процесса так, чтобы процессор подумал, что он уже вернул управление из функции;
	\item Jprobes объявлены устаревшими. Jprobes -- это надстройка над kprobes, позволяющая удобно перехватывать вызовы функций. Она самостоятельно извлечет аргументы функции из регистров или стека и вызовет обработчик, который должен иметь ту же сигнатуру, что и перехватываемая функция. Недостаток в том, что jprobes объявлены устаревшими и вырезаны из современных ядер;
	\item нетривиальные накладные расходы. Расстановка точек останова -- дорогая операция, но она выполняется единоразово. Точки останова не влияют на остальные функции, однако их обработка относительно недешевая. К счастью, для архитектуры x86\_64 реализована jump-оптимизация, существенно уменьшающая стоимость kprobes, но она все еще остается больше, чем, например, при модификации таблицы системных вызовов;
	\item kretprobes реализуются через подмену адреса возврата в стеке. Соответственно, им необходимо где-то хранить оригинальный адрес, чтобы вернуться туда после обработки kretprobe. Адреса хранятся в буфере фиксированного размера. В случае его переполнения, когда в системе выполняется слишком много одновременных вызовов перехваченной функции, kretprobes будет пропускать срабатывания.
\end{itemize}

Данный подход обладает сложной технической реализацией, а также есть вероятность возникновения ошибок после переполнения буфера памяти.

\subsection{Kernel tracepoints}

Kernel tracepoints -- это фреймворк для трассировки ядра, который позволяет встраивать точки останова в код обработчиков системных вызовов \cite{core_ftrace}.

Преимуществом данного подхода является минимальное количество действий для перехвата: нужно только вызвать функцию трассировки в необходимом месте.

Недостатками данного подхода являются:

\begin{itemize}
	\item отсутствие хорошо задокументированного API;
	\item не заработают в модуле, если включен CONFIG\_MODULE\_SIG и нет закрытого ключа для подписи.
\end{itemize}

\subsection{ftrace}

ftrace -- это фреймворк для трассирования ядра на уровне функций. ftrace был разработан Стивеном Ростедтом и добавлен в ядро в 2008 году, начиная с версии 2.6.27. Работает ftrace на базе файловой системы debugfs, которая в большинстве современных дистрибутивов Linux смонтирована по умолчанию.

Реализуется ftrace на основе ключей компилятора -pg и -mfentry, которые вставляют в начало каждой функции вызов специальной трассировочной функции mcount() или \_\_fentry\_\_(). Обычно, в пользовательских программах эта возможность компилятора используется профилировщиками, чтобы отслеживать вызовы всех функций. Ядро же использует эти функции для реализации фреймворка ftrace.

Также доступна оптимизация: динамический ftrace. Суть в том, что ядро знает расположение всех вызовов mcount() или \_\_fentry\_\_() и на ранних этапах загрузки заменяет их машинный код на инструкцию NOP -- специальную ничего не делающую инструкцию. Таким образом, если ftrace не используется, то его влияние на систему минимально \cite{tras_ftrace}.

Преимуществами данного подхода являются:

\begin{itemize}
	\item перехват любой функции по имени. Для указания интересующей функции достаточно знать только ее имя;
	\item перехват совместим с трассировкой. Очевидно, что этот способ не конфликтует с ftrace, так что с ядра все еще можно снимать очень полезные показатели производительности. 
\end{itemize}

Недостатками данного подхода являются:

\begin{itemize}
	\item требования к конфигурации ядра. Для успешного выполнения перехвата функций с помощью ftrace ядро должно предоставлять целый ряд возможностей:
		\begin{itemize}
			\item список символов kallsyms для поиска функций по имени;
			\item фреймворк ftrace в целом для выполнения трассировки;
			\item опции ftrace, критически важные для перехвата.
		\end{itemize}
\end{itemize}

Обычно ядра, используемые популярными дистрибутивами, все эти опции в себе все равно содержат, так как они не влияют на производительность и полезны при отладке \cite{core_ftrace}.

\subsection{Сравнение способов}

В качестве критериев выбора способа трассировки ядра и перехвату функций были выбраны следующие:

\begin{itemize}
	\item наличие задокументированного API;
	\item техническая простота реализации;
	\item динамическая загрузка;
	\item перехват всех функций.
\end{itemize}

В таблице \ref{class} приведено сравнение способов трассировки ядра и перехвата функций.

\begin{table}[H]
	\caption{Сравнение способов трассировки ядра и перехвата функций}
	\label{class}
	\begin{center}
		\begin{tabular}{| p{3 cm} | p{2.5 cm} | p{2.5 cm} | p{2.5 cm} | p{2.5 cm} |} 
			\hline
			& Наличие задокументированного API & Техническая простота реализации & Динамичес- кая загрузка & Перехват всех функций \\
			\hline
			Linux Security API & - & + & - & + \\
			\hline
			Модификация таблицы сиcтемных вызовов & - & + & + & - \\
			\hline
			kprobes & + & - & + & + \\
			\hline
			Kernel tracepoints & - & + & + & + \\
			\hline
			ftrace & + & + & + & + \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\section{Визуализация данных}

Визуализация количества вызовов функций нужна для того, чтобы можно было наглядно оценить состояние системы без необходимости разбираться с лог-файлами. 

\subsection{Loki}

Loki -- это набор компонентов для полноценной системы работы с логами. В отличие от других подобных систем Loki основан на идее индексировать только метаданные логов — labels (так же, как и в Prometheus), a сами логи сжимать рядом \cite{loki_logs}.

Loki-стек состоит из трех компонентов: Promtail, Loki, Grafana. Promtail собирает логи, обрабатывает их и отправляет в Loki. Loki их хранит. А Grafana умеет запрашивать данные из Loki и показывать их. Loki можно использовать не только для хранения логов и поиска по ним. Весь стек дает большие возможности по обработке и анализу поступающих данных \cite{loki_logs}.

\subsection{Grafana}

Grafana -- это платформа с открытым исходным кодом для визуализации, мониторинга и анализа данных. Grafana позволяет пользователям создавать дашборды с панелями, каждая из которых отображает определенные показатели в течение установленного периода времени. Каждый дашборд универсален, поэтому его можно настроить для конкретного проекта или с учетом любых потребностей разработки \cite{grafana}.

Искать по логам можно в специальном интерфейсе Grafana -- Explorer. Для запросов используется язык LogQL.

\section{Выводы}

В результате проведенного сравнительного анализа (таблица 1.1) был выбран способ трассировки ядра -- ftrace, обеспечивающий динамическую загрузку и перехват всех функций. 

Для сбора статистики вызовов был выбран набор компонентов Loki. 

Для визуализации данных была выбрана платформа с открытым иходным кодом Grafana.