\chapter{Структура FILE}

Описание структуры \texttt{FILE} приведено в Листинге \ref{lst:fileh}

\listingfile{FILE.h}{fileh}{C}{Файл \texttt{/usr/include/bits/types/FILE.h}}{}

Описание структуры \texttt{\_IO\_FILE} приведено в Листингах \ref{lst:iofileh} -- \ref{lst:iofileh-3}

\listingfile{struct_FILE.h}{iofileh}{C}{Файл \texttt{/usr/include/bits/types/struct\_FILE.h}, Часть 1}{linerange={1-31}}

\listingfile{struct_FILE.h}{iofileh-2}{C}{Файл \texttt{/usr/include/bits/types/struct\_FILE.h}, Часть 2}{linerange={33-88},firstnumber=33}

\newpage

\listingfile{struct_FILE.h}{iofileh-3}{C}{Файл \texttt{/usr/include/bits/types/struct\_FILE.h}, Часть 2}{linerange={89-120},firstnumber=89}

\chapter{Реализация программ}

\section{Первая программа}

\subsection{Коды программ}

\listingfile{prog_01.c}{prog-01}{C}{Открытие одного и того же файла несколько раз для чтения в одном процессе}{}

\imgs{1}{H}{1}{Программа с одним процессом}

\newpage

\listingfile{prog_01_thread.c}{prog-02-1}{C}{Открытие одного и того же файла для чтения в нескольких потоках}{}

\newpage

\imgs{1-1}{H}{0.85}{Открытие одного и того же файла для чтения в нескольких потоках}

\subsection{Схема взаимодействия структур}

\imgw{schema-1}{H}{\textwidth}{Схема взаимодействия структур}

\subsection*{Выводы}

\begin{itemize}
	\item функция \texttt{open()} создает файловый дескриптор файла (открытого только на чтение) "data.txt", т. е. запись в системной таблице открытых файлов. Поле \textbf{f\_pos} равно нулю;
	
	\item функция \texttt{fdopen()} создает указатели на структуру \texttt{\_IO\_FILE}. Поле \texttt{\_fileno} содержит дескриптор, который вернула функция \texttt{fopen()};
	
	\item функция \texttt{setvbuf()} явно задает размер буффера в 20 байт и меняет тип буферизации (для \texttt{fs1} и \texttt{fs2}) на полную;
	
	\item при первом вызове функции \texttt{fscanf()} в цикле (для \texttt{fs1}), \texttt{buff1} будет заполнен полностью -- первыми 20 символами (буквами алфавита). \texttt{f\_pos} в структуре \texttt{struct\_file} открытого файла увеличится на 20;
	
	\item при втором вызове \texttt{fscanf()} в цикле (для \texttt{fs2}) буффер \texttt{buff2} будет заполнен оставшимися 6 символами (начиная с \texttt{f\_pos});
	
	\item в цикле поочередно выводятся символы из \texttt{buff1} и \texttt{buff2};
	
	\item все это справедливо и для многопоточной реализации: в потоке, который первый получит квант, первый вызов \texttt{fscanf()} заполнит буфер и увеличит \texttt{f\_pos} в структуре \texttt{struct\_file} открытого файла, а оставшиеся 6 символов будут записаны в буфер, находящийся в другом потоке.
\end{itemize}

\newpage

\section{Вторая программа}

\subsection{Коды программ}

\listingfile{prog_02.c}{prog-02}{C}{Открытие одного и того же файла несколько раз для чтения в одном процессе}{}

\imgw{2}{H}{0.8\textwidth}{Открытие одного и того же файла несколько раз для чтения в одном процессе}

\newpage

\listingfile{prog_02_thread.c}{prog-02-1}{C}{Открытие одного и того же файла несколько раз для чтения в двух потоках}{}

\imgw{2-1}{H}{0.8\textwidth}{Открытие одного и того же файла несколько раз для чтения в двух потоках}

\newpage

\subsection{Схема взаимодействия структур}

\imgw{schema-2}{H}{1\textwidth}{Схема взаимодействия структур}

\subsection*{Вывод}

\begin{itemize}
	\item функция \texttt{open()} создает файловые дескрипторы, два раза для одного и того же файла, поэтому в программе существует две различные \texttt{struct file}, но ссылающиеся на один и тот же \texttt{struct inode};
	\item из-за того что структуры \texttt{struct file} разные, посимвольная печать просто дважды выведет содержимое файла в формате <<AAbbcc...>> (в случае однопроцессной реализации); 
	\item в случае многопоточной реализации, вывод второго потока начнется позже (нужно время, для создание этого потока) и символы перемешаются (см. рис. \ref{img:2-1}).
\end{itemize}

\newpage

\section{Третья программа}

\subsection{Схема взаимодействия структур}

\imgw{schema-3}{H}{1\textwidth}{Схема взаимодействия структур}

\subsection{Коды программ}

\listingfile{prog_03.c}{prog-03}{C}{Открытие одного и того же файла несколько раз для записи в одном процессе}{}

\imgs{3}{H}{1}{Открытие одного и того же файла несколько раз для записи в одном процессе}

\listingfile{prog_03_thread.c}{prog-03-1}{C}{Открытие одного и того же файла несколько раз для записи в двух потоках}{}

\imgs{3-1}{H}{1}{Открытие одного и того же файла несколько раз для записи в двух потоках}

\newpage

\subsection*{Вывод}

\begin{itemize}
	\item файл открывается на запись два раза, с помощью функции \texttt{fopen()};
	\item функция \texttt{fprintf()} предоставляет буферизованный вывод - буфер создается без нашего вмешательства;g
	\item изначально информация пишется в буфер, а из буфера в файл если произошло одно из событий:
		\subitem буффер полон;
		\subitem вызвана функция \texttt{fclose()};
		\subitem вызвана функция \texttt{fflush()};
	\item в случае нашей программы, информация в файл запишется в результате вызова функция \texttt{fclose()};
	\item из-за того \texttt{f\_pos} независимы для каждого дескриптора файла, запись в файл будет производится с самого начала;
	\item таким образом, информация записанная при первом вызове \texttt{fclose()} будет потеряна в результате второго вызова \texttt{fclose()}.
	\item в многопоточной реализации результат аналогичен - с помощью \texttt{pthread\_join} мы дожидаемся вызова \texttt{fclose()} для \texttt{f2} в отдельном потоке и далее вызываем \texttt{fclose()} для \texttt{f1}.
\end{itemize}

Для исключения проблемы потери данных нужно открывать файл в режиме добавления - \texttt{O\_APPEND}. Тогда операция записи в файл становится атомарной и перед каждым вызовом \texttt{write}, смещение в файле устанавливается в конец файла.
